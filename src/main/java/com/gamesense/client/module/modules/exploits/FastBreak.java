package com.gamesense.client.module.modules.exploits;

import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.setting.values.BooleanSetting;
import com.gamesense.api.setting.values.DoubleSetting;
import com.gamesense.api.setting.values.IntegerSetting;
import com.gamesense.api.setting.values.ModeSetting;
import com.gamesense.api.util.player.InventoryUtil;
import com.gamesense.api.util.world.BlockUtil;
import com.gamesense.client.GameSense;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.Category;
import com.gamesense.client.module.modules.combat.CevBreaker;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.init.MobEffects;
import net.minecraft.item.Item;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;

/**
 * A special thank to Kami147 for making this exploit public
 * https://github.com/Kami147/InstantMine/blob/main/InstantMine.java
 */

@Module.Declaration(name = "FastBreak", category = Category.Exploits)
public class FastBreak extends Module {

    ModeSetting mode;
    BooleanSetting haste;
    BooleanSetting switchPick;
    BooleanSetting switchBack;
    BooleanSetting spammer;
    DoubleSetting startDamage;
    DoubleSetting endDamage;
    IntegerSetting pickTickSwich;
    IntegerSetting spammerTickDelay;
    private int tick = 99;
    private int tickSpammer = 0;
    private int oldslot;

    public void setup() {
        ArrayList<String> Modes = new ArrayList<>();
        Modes.add("Packet");
        Modes.add("Damage");
        Modes.add("Instant");
        Modes.add("Breaker");

        mode = registerMode("Mode", Modes, "Packet");
        startDamage = registerDouble("Start Damage", 0.1, 0, 1);
        endDamage = registerDouble("End Damage", 0.9, 0, 1);
        haste = registerBoolean("Haste", false);
        switchPick = registerBoolean("Switch Pick", false);
        switchBack = registerBoolean("Switch Back", true);
        spammer = registerBoolean("Spammer", false);
        pickTickSwich = registerInteger("Pick Tick Switch", 0, 0, 20);
        spammerTickDelay = registerInteger("Spammer Tick Delay", 0, 0, 20);
    }

    private BlockPos lastBlock = null;
    private boolean packetCancel = false;
    private EnumFacing direction;
    private BlockPos blockAimed;

    public void onUpdate() {

        if (tick != 99) {
            if (tick++ == pickTickSwich.getValue()) {
                mc.player.inventory.currentItem = oldslot;
                tick = 99;
            }
        }

        // This is for making breaker working
        Minecraft.getMinecraft().playerController.blockHitDelay = 0;

        if (haste.getValue()) {
            PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
            mc.player.addPotionEffect(new PotionEffect(effect));
        }
        if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) { //disables haste when you turn the setting off
            mc.player.removePotionEffect(MobEffects.HASTE);
        }

        if (mode.getValue().equals("Breaker") && !CevBreaker.isActive) {
            if (lastBlock != null && ((spammer.getValue() && tickSpammer++ == spammerTickDelay.getValue()) || !(BlockUtil.getBlock(lastBlock) instanceof BlockAir))) {
                breakerBreak();
                tickSpammer = 0;
            }
        }

    }

    private void breakerBreak() {
        Item item;
        if ((item = mc.player.inventory.getCurrentItem().getItem()) instanceof ItemPickaxe || switchPick.getValue()) {
            if (!(item instanceof ItemPickaxe)) {
                oldslot = mc.player.inventory.currentItem;
                mc.player.inventory.currentItem = InventoryUtil.findFirstItemSlot(ItemPickaxe.class, 0, 9);
            }
            // Send STOP_DESTROY_BLOCK
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    lastBlock, direction));
            if (oldslot != -1 && switchBack.getValue()) {
                tick = 0;
            }
        }
    }

    @EventHandler
    private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

        if (mc.world == null || mc.player == null) {
            return;
        }
        if (canBreak(event.getBlockPos())) {

            //Packet mine
            if (mode.getValue().equalsIgnoreCase("Packet")) {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                event.cancel();
            } else
                //Damage
                if (mode.getValue().equalsIgnoreCase("Damage")) {

                    if (mc.playerController.curBlockDamageMP < startDamage.getValue())
                        mc.playerController.curBlockDamageMP = startDamage.getValue().floatValue();

                    if (mc.playerController.curBlockDamageMP >= endDamage.getValue()) {
                        mc.playerController.curBlockDamageMP = 1.0f;
                    }
                } else if (mode.getValue().equalsIgnoreCase("Instant")) {
                    mc.player.swingArm(EnumHand.MAIN_HAND);
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
                    mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
                    mc.world.setBlockToAir(event.getBlockPos());
                } else if (mode.getValue().equalsIgnoreCase("Breaker")) {
				/*
					This is what i understood about this module:
					First, it has to break the block normally with START_DESTROY_BLOCK and then STOP_DESTROY_BlOCK
					the second block, it just spam STOP_DESTROY_BLOCK, making it insta.
				 */
                    blockAimed = event.getBlockPos();
                    if (canBreak(event.getBlockPos())) {
                        // If it's not the same block
                        if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
                            // Start destroying with START_DESTROY_BLOCK
                            mc.player.swingArm(EnumHand.MAIN_HAND);
                            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                                    event.getBlockPos(), event.getEnumFacing()));
                            // Save for preventing it doing again packet mine
                            lastBlock = event.getBlockPos();
                            direction = event.getEnumFacing();
                        }

                        breakerBreak();
                        // Cancel the normal mine
                        event.cancel();

                    }
                }
        }
    });

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public void onDisable() {
        GameSense.EVENT_BUS.unsubscribe(this);
        if (haste.getValue())
            mc.player.removePotionEffect(MobEffects.HASTE);
    }
}