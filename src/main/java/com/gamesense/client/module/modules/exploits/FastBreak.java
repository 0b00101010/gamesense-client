package com.gamesense.client.module.modules.exploits;

/*
	A special thank to Kami for making this exploit public
	https://github.com/Kami147/InstantMine/blob/main/InstantMine.java

 */

import com.gamesense.api.event.events.DamageBlockEvent;
import com.gamesense.api.setting.Setting;
import com.gamesense.client.GameSense;
import com.gamesense.client.module.Module;
import com.gamesense.client.module.modules.Category;
import me.zero.alpine.listener.EventHandler;
import me.zero.alpine.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.init.MobEffects;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.potion.PotionEffect;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;

@Module.Declaration(name = "FastBreak", category = Category.Exploits)
public class FastBreak extends Module {

	Setting.Mode mode;
	Setting.Boolean haste;
	Setting.Double startDamage;
	Setting.Double endDamage;

	private BlockPos lastBlock;
	private boolean packetCancel = false;
	private EnumFacing direction;
	private BlockPos blockAimed;

	public void setup() {
		ArrayList<String> Modes = new ArrayList<>();
		Modes.add("Packet");
		Modes.add("Damage");
		Modes.add("Instant");
		Modes.add("Breaker");

		mode = registerMode("Mode", Modes, "Packet");
		startDamage = registerDouble("Start Damage", 0.1, 0, 1);
		endDamage = registerDouble("End Damage", 0.9, 0, 1);
		haste = registerBoolean("Haste", false);
	}

	public void onUpdate() {
		// This is for making breaker working
		Minecraft.getMinecraft().playerController.blockHitDelay = 0;

		if (haste.getValue()) {
			PotionEffect effect = new PotionEffect(MobEffects.HASTE, 80950, 1, false, false);
			mc.player.addPotionEffect(new PotionEffect(effect));
		}
		if (!(haste.getValue()) && mc.player.isPotionActive(MobEffects.HASTE)) { //disables haste when you turn the setting off
			mc.player.removePotionEffect(MobEffects.HASTE);
		}

	}

	@EventHandler
	private final Listener<DamageBlockEvent> listener = new Listener<>(event -> {

	if (mc.world == null || mc.player == null) {
		return;
	}
		if (canBreak(event.getBlockPos())) {

			//Packet mine
			if (mode.getValue().equalsIgnoreCase("Packet")) {
				mc.player.swingArm(EnumHand.MAIN_HAND);
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
				event.cancel();
			}
			else
			//Damage
			if (mode.getValue().equalsIgnoreCase("Damage")) {

				if (mc.playerController.curBlockDamageMP < startDamage.getValue())
					mc.playerController.curBlockDamageMP = (float) startDamage.getValue() ;

				if (mc.playerController.curBlockDamageMP >= endDamage.getValue()){
					mc.playerController.curBlockDamageMP = 1.0f;
				}
			}
			else
			if (mode.getValue().equalsIgnoreCase("Instant")) {
				mc.player.swingArm(EnumHand.MAIN_HAND);
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing()));
				mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.getBlockPos(), event.getEnumFacing() ));
				mc.playerController.onPlayerDestroyBlock(event.getBlockPos());
				mc.world.setBlockToAir(event.getBlockPos());
			}
			else
			if (mode.getValue().equalsIgnoreCase("Breaker")) {
				/*
					This is what i understood about this module:
					First, it has to break the block normally with START_DESTROY_BLOCK and then STOP_DESTROY_BlOCK
					the second block, it just spam STOP_DESTROY_BLOCK, making it insta.
				 */
				blockAimed = event.getBlockPos();
				if (canBreak(event.getBlockPos())) {
					// If it's not the same block
					if (lastBlock == null || event.getBlockPos().x != lastBlock.x || event.getBlockPos().y != lastBlock.y || event.getBlockPos().z != lastBlock.z) {
						// Start destroying with START_DESTROY_BLOCK
						mc.player.swingArm(EnumHand.MAIN_HAND);
						mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
								event.getBlockPos(), event.getEnumFacing()));
						// Save for preventing it doing again packet mine
						lastBlock = event.getBlockPos();
						direction = event.getEnumFacing();
					}

					// Send STOP_DESTROY_BLOCK
					mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
							lastBlock, direction));
					// Cancel the normal mine
					event.cancel();

				}
			}
		}
	});

	private boolean canBreak(BlockPos pos) {
		final IBlockState blockState = mc.world.getBlockState(pos);
		final Block block = blockState.getBlock();
		return block.getBlockHardness(blockState, mc.world, pos) != -1;
	}

	public void onDisable() {
		GameSense.EVENT_BUS.unsubscribe(this);
		if (haste.getValue())
			mc.player.removePotionEffect(MobEffects.HASTE);
	}
}